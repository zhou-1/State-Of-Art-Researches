## 云原生（Cloud Native）     

云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。      
这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。     

### 云原生的设计哲学    
云原生不是指在容器中运行应用程序。   
就像云改变了业务和基础设施之间的关系一样，云原生应用程序也改变了应用程序和基础设施之间的关系。     
云原生应用程序被设计为在平台上运行，并设计用于<b>弹性，敏捷性，可操作性和可观察性</b>。弹性包含失败而不是试图阻止它们；它利用了在平台上运行的动态特性。敏捷性允许快速部署和快速迭代。可操作性从应用程序内部控制应用程序生命周期，而不是依赖外部进程和监视器。可观察性提供信息来回答有关应用程序状态的问题。         
以下是实现云原生应用程序所需特性的常用方法：微服务, 健康报告, 遥测数据, 弹性, 声明式的而不是命令式的。       
开发人员可以将其实施为命令或过程信号，以便应用程序在执行自我检查之后响应，或者更常见的是：通过应用程序提供Web服务，返回HTTP状态码来检查健康状态。     
云原生应用程序不能直接在PaaS上运行或与服务器的操作系统紧密耦合。它们期望在一个拥有大多数自治系统的动态环境中运行。     

### Playing with Kubernetes        
https://labs.play-with-k8s.com/     
Play with Kuberentes (PWK) is a project hacked by Marcos Lilljedahl and Jonathan Leibiusky and sponsored by Docker Inc.      
相当于Kubernetes世界的“Hello World”！而且除了一台可以上网的电脑和浏览器之外不需要再准备任何东西，甚至（至少目前为止）不需要注册账号，上手即玩。     
创建Kubernetes集群：启动第一个实例作为Master节点，在web终端上执行（初始化master节点，初始化集群网络，执行初始化命令，启动新的实例作为node节点根据master节点上的提示在新的web终端上执行）   

### 快速部署一个云原生本地实验环境     
Mac/Linux，不支持Windows；支持Kubernetes1.9以上版本（支持当前Kubernetes最新版本1.11.1）；8G以上内存      
访问Kubernetes集群的方式有三种：本地访问；在VM内部访问；kubernetes dashboard       

### 使用Rancher在阿里云上部署Kubernetes集群     


### Kubernetes与云原生应用概览     
从云计算到微服务再到云原生计算.      
说白了，云计算就是一种配置资源的方式，根据资源配置方式的不同我们可以把云计算从宏观上分为以下三种类型：     
1. IaaS：这是为了想要建立自己的商业模式并进行自定义的客户，例如亚马逊的EC2、S3存储、Rackspace虚拟机等都是IaaS。    
2. PaaS：工具和服务的集合，对于想用它来构建自己的应用程序或者想快速得将应用程序部署到生产环境而不必关心底层硬件的用户和开发者来说是特别有用的，比如Cloud Foundry、Google App Engine、Heroku等。     
3. SaaS：终端用户可以直接使用的应用程序。这个就太多，我们生活中用到的很多软件都是SaaS服务，只要基于互联网来提供的服务基本都是SaaS服务，有的服务是免费的，比如Google Docs，还有更多的是根据我们购买的Plan和使用量付费，比如GitHub、各种云存储。      
#### 微服务   
微服务（Microservices）这个词比较新颖，但是其实这种架构设计理念早就有了。微服务是一种分布式架构设计理念，为了推动细粒度服务的使用，这些服务要能协同工作，每个服务都有自己的生命周期。一个微服务就是一个独立的实体，可以独立的部署在PAAS平台上，也可以作为一个独立的进程在主机中运行。服务之间通过API访问，修改一个服务不会影响其它服务。     
#### Cloud Native 云原生    
![cloud native](https://github.com/zhou-1/State-Of-Art-Researches/blob/master/Kubernetes/imgs/1.PNG)     
云原生：微服务，DevOps，持续交付，容器化（微服务的最佳载体）。        
为了解决传统应用升级缓慢、架构臃肿、不能快速迭代、故障不能快速定位、问题无法快速解决等问题，云原生这一概念横空出世。云原生可以改进应用开发的效率，改变企业的组织结构，甚至会在文化层面上直接影响一个公司的决策。另外，云原生也很好地解释了云上运行的应用应该具备什么样的架构特性——敏捷性、可扩展性、故障可恢复性。            
#### Kubernetes与云原生的关系    
Kuberentes可以说是乘着Docker和微服务的东风，一经推出便迅速蹿红，它的很多设计思想都契合了微服务和云原生应用的设计法则，这其中最著名的就是开发了Heroku PaaS平台的工程师们总结的 Twelve-factor App了。       
Kubernetes是Google基于Borg开源的容器编排调度引擎，作为CNCF（Cloud Native Computing Foundation）最重要的组件之一，它的目标不仅仅是一个编排系统，而是提供一个规范，可以让你来描述集群的架构，定义服务的最终状态，Kubernetes可以帮你将系统自动得达到和维持在这个状态。     
更直白的说，Kubernetes用户可以通过编写一个yaml或者json格式的配置文件，也可以通过工具/代码生成或直接请求Kubernetes API创建应用，该配置文件中包含了用户想要应用程序保持的状态，不论整个Kubernetes集群中的个别主机发生什么问题，都不会影响应用程序的状态，你还可以通过改变该配置文件或请求Kubernetes API来改变应用程序的状态。       
#### 12因素应用     
大家不要孤立的来看这每一个因素，将其与自己软件开发流程联系起来，这12个因素大致就是按照软件从开发到交付的流程顺序来写的。       
1.基准代码。每个代码仓库（repo）都生成docker image保存到镜像仓库中，并使用唯一的ID管理，在Jenkins中使用编译时的ID。        
2.依赖。显式的声明代码中的依赖，使用软件包管理工具声明，比如Go中的Glide。        
3.配置。将配置与代码分离，应用部署到Kubernetes中可以使用容器的环境变量或ConfigMap挂载到容器中。       
4.后端服务。把后端服务当作附加资源，实质上是计算存储分离和降低服务耦合，分解单体应用。     
5.构建、发布、运行。严格分离构建和运行，每次修改代码生成新的镜像，重新发布，不能直接修改运行时的代码和配置。      
6.进程。应用程序进程应该是无状态的，这意味着再次重启后还可以计算出原先的状态。     
7.端口绑定。在Kubernetes中每个Pod都有独立的IP，每个运行在Pod中的应用不必关心端口是否重复，只需在service中指定端口，集群内的service通过配置互相发现。       
8.并发。每个容器都是一个进程，通过增加容器的副本数实现并发。    
9.易处理。快速启动和优雅终止可最大化健壮性，Kuberentes优秀的Pod生存周期控制。      
10.开发环境与线上环境等价。Kubernetes中可以创建多个namespace，使用相同的镜像可以很方便的复制一套环境出来，镜像的使用可以很方便的部署一个后端服务。    
11.日志。把日志当作事件流，使用stdout输出并收集汇聚起来，例如到ES中统一查看。      
12.管理进程。后台管理任务当作一次性进程运行，kubectl exec进入容器内部操作。        
#### Kubernetes中的资源管理与容器设计模式      
Kubernetes通过声明式配置，真正让开发人员能够理解应用的状态，并通过同一份配置可以立马启动一个一模一样的环境，大大提高了应用开发和部署的效率，其中Kubernetes设计的多种资源类型可以帮助我们定义应用的运行状态，并使用资源配置来细粒度的明确限制应用的资源使用。     
在 Kubernetes 系统中，Kubernetes 对象 是持久化的条目。Kubernetes 使用这些条目去表示整个集群的状态。特别地，它们描述了如下信息：什么容器化应用在运行（以及在哪个 Node 上）；可以被应用使用的资源；关于应用如何表现的策略，比如重启策略、升级策略，以及容错策略。     
#### 部署Kubernetes集群    
创建 TLS 证书和秘钥   
创建kubeconfig文件   
创建高可用etcd集群    
安装kubectl命令行工具    
部署master节点    
安装flannel网络插件    
部署node节点   
安装kubedns插件   
安装dashboard插件    
安装heapster插件   
安装EFK插件      
  


































