# 7. THE SINGLE RESPONSIBILITY PRINCIPLE 单一职责原则      

在历史上，我们曾经这样描述 SRP 这一设计原则：任何一个软件模块都应该有且仅有一个被修改的原因。     
我们也可以这样描述 SRP：任何一个软件模块都应该只对一个用户（User）或系统利益相关者（Stakeholder）负责。     
对于 SRP 的最终描述就变成了：<b>任何一个软件模块都应该只对某一类行为者负责。</b>    

<hr>
SYMPTOM 1: ACCIDENTAL DUPLICATION 反面案例 1：重复的假象   
这是我最喜欢举的一个例子：某个工资管理程序中的 Employee 类有三个函数 calculatePay()、reportHours() 和 save()    
如你所见，这个类的三个函数分别对应的是三类非常不同的行为者，违反了 SRP 设计原则。    
calculatePay() 函数是由财务部门制定的，他们负责向 CFO 汇报。reportHours() 函数是由人力资源部门制定并使用的，他们负责向 COO 汇报。save() 函数是由 DBA 制定的，他们负责向 CTO 汇报。     
接下来，假设 CFO 团队需要修改正常工作时数的计算方法，而 COO 带领的 HR 团队不需要这个修改，因为他们对数据的用法是不同的。这时候，负责这项修改的程序员会注意到 calculatePay() 函数调用了 regularHours() 函数，但可能不会注意到该函数会同时被 reportHours() 调用。于是，该程序员就这样按照要求进行了修改，同时 CFO 团队的成员验证了新算法工作正常。这项修改最终被成功部署上线了。但是，COO 团队显然完全不知道这些事情的发生，HR 仍然在使用 reportHours() 产生的报表，随后就会发现他们的数据出错了！最终这个问题让 COO 十分愤怒，因为这些错误的数据给公司造成了几百万美元的损失。    
与此类似的事情我们肯定多多少少都经历过。这类问题发生的根源就是因为我们将不同行为者所依赖的代码强凑到了一起。对此，SRP 强调这类代码一定要被分开。    

<hr>    
SYMPTOM 2: MERGES 反面案例 2：代码合井    
很可能出现两个来自不同团队的程序员分别对 Employee 类进行 修改的情况。不出意外的话，他们各自的修改一定会互相冲突，这就必须要进行代码合并。在这个例子中，这次代码合并不仅有可能让 CTO 和 COO 要求的功能出错，甚至连 CFO 原本正常的功能也可能收到影响。     
它们的一个共同点是，多人为了不同的目的修改了同一份源代码，这很容易造成问题的产生。而避免这种问题产生的方法就是将服务不同行为者的代码进行切分。        

<hr>
SOLUTIONS 解决方案    
最简单直接的办法是将数据与函数分离，设计三个类共同使用一个不包括函数的、十分简单的 EmployeeData 类, 每个类只包含与之相关的函数代码，互相不可见，这样就不存在互相依赖的情况了。    

<hr>   
单一职责原则主要讨论的是函数和类之间的关系——但是它在两个讨论层面上会以不同的形式出现。在组件层面，我们可以将其称为共同闭包原则（Common Closure Principle)，在软件架构层面，它则是用于奠定架构边界的变更轴心（Axis of Change）。    

